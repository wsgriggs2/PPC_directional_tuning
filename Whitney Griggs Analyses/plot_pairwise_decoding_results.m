%% Plot results of the pairwise decoding analysis
% Uses results generated by
% BCI_CV_direction_multicoder_pairwise_performance
%% Initialize workspace
clear; clc; close all;

%% Load across session performance
% Save out the figures for accuracy over time
base_filename = '*pairwise_session_*decoding_performance_*.mat';
[filename, pathname] = uigetfile(fullfile(get_user_data_path('pathType','Output'),'across session analyses',base_filename), 'Load across session performance');

% save the results file
fprintf('Loading %s...', fullfile(pathname, filename));
load(fullfile(pathname, filename), 'session_run_list', ...
    'across_session_performance', ...
    'best_accuracy', 'best_angular_error', 'analysis_parameters', ...
    'transform_matrices', 'align_to_session_num', ...
    'align_all_to_one_session', 'Monkey', ...
    'pvalues_accuracy', 'pvalues_angular_error');

fprintf('done.\n')

data_save_root = get_user_data_path('pathType', 'across session analyses');

save_plots = true;

%% Group sessions together
session_id = NaN(size(session_run_list, 1), 1);

unique_sessions = unique(session_run_list(:, 1));
for session_num = 1:length(unique_sessions)
    session_id(session_run_list(:, 1) == unique_sessions(session_num)) = session_num;
end

%% Reconstruct some variables
project_record_filename = 'ProjectRecord_paper.json';
num_sessions = length(unique_sessions);
ProjectRecord = load_json_as_table(project_record_filename);

%% Visualize each confusion matrix
combined_label_strings = {'Left Down', 'Center Down', 'Right Down', ...
    'Left Center',  'Middle', 'Right Center', ...
    'Left Up', 'Center Up', 'Right Up'};
combined_label_strings = {'Ipsilateral Down', 'Center Down', 'Contralateral Down', ...
    'Ipsilateral Center',  'Middle', 'Contralateral Center', ...
    'Ipsilateral Up', 'Center Up', 'Contralateral Up'};
reordered_label_strings = combined_label_strings([7 8 9 6 3 2 1 4 5]);

for session1 = 1:num_sessions
    figure; 
    tiledlayout('flow');
    for session2 = 1:num_sessions
        current_results = across_session_performance{session1, session2};
        last_timepoint_results = current_results{end};
        
        confusion = last_timepoint_results.confusion;
        reordered_confusion_mat = confusion([7 8 9 6 3 2 1 4 5], [7 8 9 6 3 2 1 4 5]);

        nexttile();
    imagesc_confusion_matrix(reordered_confusion_mat(:, 1:8)', ...
        'label_strings', reordered_label_strings, ...
        'title', '', ...
        'FontColor', 'k');
    title(sprintf('train S%d\ntest S%d', unique_sessions(session1), unique_sessions(session2)));
    end
end


%% Date of each session
date_of_sessions = datetime(zeros(num_sessions,1), 0, 0);
for session_num = 1:num_sessions
    
    session_ind = session_id == session_num;
    
    % Take first run in a session if multiple
    num_runs_in_session = nnz(session_ind);
    if num_runs_in_session > 1
        session_ind = find(session_ind, 1);
    end
    
    session_nums = session_run_list(session_ind,1);
    run_nums = session_run_list(session_ind,2);
    indx = ismember(ProjectRecord.Session, session_nums) & ismember(ProjectRecord.Run, run_nums);
    date_of_sessions(session_num) = datetime(ProjectRecord.Date(indx), 'InputFormat', 'dd-MMM-yyyy');
    
end

% Pairwise difference
days_between_sessions = NaN(num_sessions);
for session_num = 1:num_sessions
    days_between_sessions(session_num, :) = days(date_of_sessions - date_of_sessions(session_num));
end


%% Plane of each session
plane_of_sessions = zeros(num_sessions,1);
for session_num = 1:num_sessions
    session_ind = session_id == session_num;
    
    % Take first run in a session if multiple
    num_runs_in_session = nnz(session_ind);
    if num_runs_in_session > 1
        session_ind = find(session_ind, 1);
    end
    
    session_nums = session_run_list(session_ind,1);
    run_nums = session_run_list(session_ind,2);
    indx = ismember(ProjectRecord.Session, session_nums) & ismember(ProjectRecord.Run, run_nums);
    plane_of_session_temp =ProjectRecord.Slot(indx);
    plane_of_sessions(session_num) = sscanf(plane_of_session_temp,'cor_%d');
end



%% Plot across session performance - no lines
figure('units', 'normalized', 'OuterPosition', [0 0 1 1]);
tld = tiledlayout(1, 3);
pvalue_threshold = 0.01;
colors_to_use = distinguishable_colors(2);

days_since_train_session_1D = days_between_sessions(:);

% Accuracy vs time
nexttile();
best_accuracy_1D = best_accuracy(:);

% Label significance by color
pvalue_accuracy_1D = pvalues_accuracy(:);
significant_ind = pvalue_accuracy_1D<=pvalue_threshold;
hold on;
for i = 1:2
    plot(abs(days_since_train_session_1D(significant_ind == (i-1))), best_accuracy_1D(significant_ind == (i-1)), '.', ...
        'MarkerSize', 10, ...
        'Color', colors_to_use(i, :));
end
hold off;
ylabel('Accuracy');
xlimits = xlim;
xlim([xlimits(1) xlimits(2)]);
xlabel('Time between training session (days)');
title('Accuracy vs abs(time)');

% Calculate linear fit for accuracy vs image similarity
x = abs(days_since_train_session_1D);
y = best_accuracy_1D;
accuracy_mdl = fitlm(x, y)
accuracy_mdl_fit = polyfit(x, y, 1); % x = x data, y = y data, 1 = order of the polynomial i.e a straight line

[pear_corr_accuracy, corr_pvalue_accuracy] = corr(x, y);

hold on;
plot(x, polyval(accuracy_mdl_fit,x))
xlimits = xlim;
ylimits = ylim;
text(xlimits(1)+(0.05*(xlimits(2)-xlimits(1))), ylimits(1) + diff(ylimits)*0.05, ...
    sprintf('Accuracy R^2=%0.3f p=%0.3f', pear_corr_accuracy^2, corr_pvalue_accuracy));
hold off

if any(pvalues_angular_error>pvalue_threshold, 'all')
        legend('ns', sprintf('p<%0.4f', pvalue_threshold), 'linear fit', ...
        'Location', 'best');
else
    legend( sprintf('p<%0.4f', pvalue_threshold),'linear fit', ...
        'Location', 'best');
end

%Normalized accuracy vs time
nexttile();
best_accuracy_normalized = best_accuracy./repmat(diag(best_accuracy), 1, size(best_accuracy, 2));
best_accuracy_normalized_1D = best_accuracy_normalized(:);

% Label significance by color
pvalue_accuracy_1D = pvalues_accuracy(:);
significant_ind = pvalue_accuracy_1D<=pvalue_threshold;
hold on;
for i = 1:2
    plot(abs(days_since_train_session_1D(significant_ind == (i-1))), best_accuracy_normalized_1D(significant_ind == (i-1)), '.', ...
        'MarkerSize', 10, ...
        'Color', colors_to_use(i, :));
end
hold off;
ylabel('Normalized performance to training sessions');
xlimits = xlim;
xlim([xlimits(1) xlimits(2)]);
ylim([0 max(best_accuracy_normalized_1D)]);
xlabel('Time between training session (days)');
title('Normalized Accuracy vs abs(time)');


% Calculate linear fit 
x = abs(days_since_train_session_1D);
y = best_accuracy_normalized_1D;
norm_accuracy_mdl = fitlm(x, y)
accuracy_mdl_fit = polyfit(x, y, 1); % x = x data, y = y data, 1 = order of the polynomial i.e a straight line

[pear_corr_accuracy, corr_pvalue_accuracy] = corr(x, y);

hold on;
plot(x, polyval(accuracy_mdl_fit,x))
xlimits = xlim;
ylimits = ylim;
text(xlimits(1)+(0.05*(xlimits(2)-xlimits(1))), ylimits(1) + diff(ylimits)*0.05, ...
    sprintf('NormAccuracy R^2=%0.3f p=%0.3f', pear_corr_accuracy^2, corr_pvalue_accuracy));
hold off

if any(pvalues_angular_error>pvalue_threshold, 'all')
        legend('ns', sprintf('p<%0.4f', pvalue_threshold), 'linear fit', ...
        'Location', 'best');
else
    legend( sprintf('p<%0.4f', pvalue_threshold),'linear fit', ...
        'Location', 'best');
end

% Plot mean absolute angular error across sessions
nexttile();

% Add one for the training session and then sort
best_angular_error_1D = 180/pi*best_angular_error(:);

% Label significance by color
pvalue_angular_error_1D = pvalues_angular_error(:);
significant_ind = pvalue_angular_error_1D<=pvalue_threshold;
hold on;
for i = 1:2
    plot(abs(days_since_train_session_1D(significant_ind == (i-1))), best_angular_error_1D(significant_ind == (i-1)), '.', ...
        'MarkerSize', 10, ...
        'Color', colors_to_use(i, :));
end
hold off;

ylabel('Mean absolute angular error (deg)');
xlimits = xlim;
xlim([xlimits(1) xlimits(2)]);
ylim([15 100]);
xlabel('Time between training session (days)');
title('Angular Error vs abs(time)');

% Calculate linear fit for accuracy
x = abs(days_since_train_session_1D);
y = best_angular_error_1D;
angular_error_mdl = fitlm(x, y)
angular_error_mdl_fit = polyfit(x, y, 1); % x = x data, y = y data, 1 = order of the polynomial i.e a straight line

[pear_corr_accuracy, corr_pvalue_accuracy] = corr(x, y);

hold on;
plot(x, polyval(angular_error_mdl_fit,x));
xlimits = xlim;
ylimits = ylim;
text(xlimits(1)+(0.05*(xlimits(2)-xlimits(1))), ylimits(1) + diff(ylimits)*0.05, ...
    sprintf('MAAE R^2=%0.3f p=%0.3f', pear_corr_accuracy^2, corr_pvalue_accuracy));
hold off

if any(pvalues_angular_error>pvalue_threshold, 'all')
        legend('ns', sprintf('p<%0.4f', pvalue_threshold), 'linear fit', ...
        'Location', 'best');
else
    legend( sprintf('p<%0.4f', pvalue_threshold),'linear fit', ...
        'Location', 'best');
end


if save_plots
    suggested_filename = sprintf('pairwise_traintest_performance_acrossTime_%s_dg%s.svg', Monkey, datetime('now', 'Format', 'yyyyMMdd'));
    suggested_path = fullfile(get_user_data_path('pathType', 'decoding'));
    saveas(gcf, fullfile(suggested_path, suggested_filename));
end

%% Plot across session performance - with lines
figure;
tld = tiledlayout(1, 3);
pvalue_threshold = 0.01;
colors_to_use = distinguishable_colors(11);

marker_styles = {'--o', '-'};

% Accuracy vs time
nexttile();

ax_h = [];
legend_labels = cell(num_sessions, 1);
hold on;
for train_session = 1:num_sessions
    current_days_since_train = days_between_sessions(train_session, :);
    current_session_accuracy = best_accuracy(train_session, :);
    current_session_pvalue = pvalues_accuracy(train_session, :);
    significant_ind = current_session_pvalue<=pvalue_threshold;
    
    
    ax_h(train_session) = plot(current_days_since_train, current_session_accuracy, ...
        'Color', colors_to_use(train_session, :));
    
    plot(current_days_since_train(~significant_ind), current_session_accuracy(~significant_ind), ...
        'Color', colors_to_use(train_session, :), ...
        'Marker', 'o', ...
        'MarkerSize', 5);
    
    legend_labels{train_session} = sprintf('Session %d', unique_sessions(train_session));
end
hold off;
ylabel('Accuracy');
xlimits = xlim;
xlim([xlimits(1) xlimits(2)]);
ylim([0 100]);
xlabel('Time since training session (days)');
title('Accuracy vs time');
legend(ax_h, legend_labels, ...
    'Location', 'best');

%Normalized accuracy vs time
nexttile();
hold on;
for train_session = 1:num_sessions
    current_days_since_train = days_between_sessions(train_session, :);
    current_session_accuracy = best_accuracy_normalized(train_session, :);
    current_session_pvalue = pvalues_accuracy(train_session, :);
    significant_ind = current_session_pvalue<=pvalue_threshold;
    
    
    ax_h(train_session) = plot(current_days_since_train, current_session_accuracy, ...
        'Color', colors_to_use(train_session, :));
    
    plot(current_days_since_train(~significant_ind), current_session_accuracy(~significant_ind), ...
        'Color', colors_to_use(train_session, :), ...
        'Marker', 'o', ...
        'MarkerSize', 5);
    
    legend_labels{train_session} = sprintf('Session %d', unique_sessions(train_session));
    
end
hold off;
ylabel('Accuracy');
xlimits = xlim;
xlim([xlimits(1) xlimits(2)]);
ylim([0 max(best_accuracy_normalized, [], 'all')]);
xlabel('Time since training session (days)');
title('Normalized Accuracy vs time');


% Plot mean absolute angular error across sessions
nexttile();

hold on;
for train_session = 1:num_sessions
    current_days_since_train = days_between_sessions(train_session, :);
    current_session_accuracy = 180/pi*best_angular_error(train_session, :);
    current_session_pvalue = pvalues_angular_error(train_session, :);
    significant_ind = current_session_pvalue<=pvalue_threshold;
    
    
    plot(current_days_since_train, current_session_accuracy, ...
        'Color', colors_to_use(train_session, :));
    
    plot(current_days_since_train(~significant_ind), current_session_accuracy(~significant_ind), ...
        'Color', colors_to_use(train_session, :), ...
        'Marker', 'o', ...
        'MarkerSize', 5);
end
hold off;

ylabel('Mean absolute angular error (deg)');
xlimits = xlim;
xlim([xlimits(1) xlimits(2)]);
ylim([15 100]);
xlabel('Time since training session (days)');
title('MAAE vs time');
%% Display the angiograms associated with each session
load_new_angiograms = true;

pixelsize = 0.1;

% Restrict to just sessions
% The sort is needed here to match the sort we did above by date. Since
% session numbers always increase across days, this works.
[unique_sessions, ia, ic] = unique(session_run_list(:, 1));

num_unique_sessions = length(unique_sessions);

% use concatenateRuns to load data
[data_labels, angiogram_unaligned, UF] = deal(cell(length(unique_sessions), 1));


if load_new_angiograms
    for session = 1:num_unique_sessions
        [~, ~, ~, angiogram_unaligned{session}, UF{session}] = ...
            concatenateRuns(...
            session_run_list(ia(session), :), ...
            true, ...
            'manual_alignment', true, ...
            'project_record_filename', project_record_filename);
    end
else
    try
        [loadfile, loadpath] = uigetfile(fullfile(get_user_data_path('pathType', 'decoding'), sprintf('%s_pairwise_aligned_angiograms_dateGenerated*.mat', Monkey)));
        load_fullfile = fullfile(loadpath, loadfile);
        load(load_fullfile, 'angiogram_unaligned', 'UF');
    catch
        error('Please set `load_new_angiograms` to true and rerun this code cell');
    end
end

for session = 1:num_unique_sessions
    ProjectRecord_ind = ProjectRecord.Session == session_run_list(ia(session), 1) & ProjectRecord.Run == session_run_list(ia(session), 2);
    Session = ProjectRecord.Session(ProjectRecord_ind);
    data_labels{session} = sprintf('%s - S%d', datestr(date_of_sessions(session), 'mmm DD, YYYY'), Session);
end

%% Display unaligned angiograms
if exist('angiogram_unaligned', 'var')
    figure;
    tld = tiledlayout('flow');
    for session = 1:num_unique_sessions
        ProjectRecord_ind = ProjectRecord.Session == session_run_list(ia(session), 1) & ProjectRecord.Run == session_run_list(ia(session), 2);
        Session = ProjectRecord.Session(ProjectRecord_ind);
        Run = ProjectRecord.Run(ProjectRecord_ind);
        
        % Scale angiogram to better show stripes (if present)
        angiogram_scaled = nthroot(angiogram_unaligned{session}, 5);
        
        % Replace zeros with NaN for visualization
        angiogram_scaled(angiogram_scaled==0) = NaN;
        
        X_img_mm = pixelsize/2 + (0:size(angiogram_scaled,2)-1)*pixelsize;
        try
            Z_img_mm = pixelsize/2 + (0:size(angiogram_scaled,1)-1)*pixelsize + UF{session}.Depth(1);
        catch
            warning('Missing info S%dR%d', Session, Run);
            Z_img_mm = pixelsize/2 + (0:size(angiogram_scaled,1)-1)*pixelsize;
        end
        
        nexttile();
        figure_title = sprintf('Average Doppler Image - S%dR%d \nPlane - %s    Monkey - %s\nDate Acquired: %s', Session, Run, ProjectRecord.Slot{ProjectRecord_ind}, ProjectRecord.Monkey{ProjectRecord_ind}, ProjectRecord.Date{ProjectRecord_ind} );
        plot_angiogram(angiogram_scaled, X_img_mm, Z_img_mm, ...
            'title', figure_title,...
            'colormap', 'inferno', ...
            'show_colormap', false)
        
        drawnow;
        data_labels{session} = sprintf('%s - S%d', datestr(date_of_sessions(session), 'mmm DD, YYYY'), Session);
    end
    
    tld.TileSpacing = 'tight';
    tld.Padding = 'tight';
end

%% Align angiogram
realign_angiogram = false;

angiogram_aligned = cell(num_sessions);
if realign_angiogram || load_new_angiograms
    
    for session1 = 1:num_sessions
        session1_angiogram = angiogram_unaligned{session1};
        for session2 = 1:num_sessions
            if session1 == session2
                angiogram_aligned{session1, session2} = session1_angiogram;
            else
                session2_angiogram = angiogram_unaligned{session2};
                
                % Align image to match previously loaded data
                angiogram_aligned{session1, session2} = imwarp(...
                    angiogram_unaligned{session2}, ...
                    transform_matrices{session1, session2}, ...
                    'OutputView', imref2d(size(session1_angiogram)), ...
                    'FillValues', 0);
            end
        end
        
        save_fullfile = fullfile(data_save_root, sprintf('%s_pairwise_aligned_angiograms_dateGenerated_%s.mat', Monkey, datetime('today', format='yyyyMMdd')));
        save(save_fullfile, 'angiogram_unaligned', 'angiogram_aligned', 'UF');
    end
else
    try
        load_fullfile = fullfile(loadpath, loadfile);
        load(load_fullfile, 'angiogram_aligned', 'UF');
    catch
        error('Please set `realign_angiogram` to true and rerun this code cell');
    end
end

%% Visualize pairwise accuracy and angular error by date
superimpose_significance = true;

figure; 
tld = tiledlayout(2, 3);
nexttile();
imagesc(best_accuracy, [100/8 max(best_accuracy, [], 'all')]); 
cb = colorbar;
cb.Label.String = 'Percent correct (%)';
colormap(gca,inferno);
xticks(1:num_unique_sessions);
xticklabels(data_labels);
yticks(1:num_unique_sessions);
yticklabels(data_labels);
axis image;
colorplot_h = gca;
title('Accuracy');
xlabel('Testing session');
ylabel('Training session');


if superimpose_significance
    marker_text = '*';
    
     for train_session = 1:num_sessions
        for test_session = 1:num_sessions
            significance_value = pvalues_accuracy(train_session, test_session);
            if significance_value<1e-6
                marker_text = '***';
            elseif significance_value<1e-4
                marker_text = '**';
            elseif significance_value<1e-2
                marker_text = '*';
            else
                marker_text = 'ns';
            end
            
            color_limits = colorplot_h.CLim;
            color_threshold = color_limits(2) - diff(color_limits)/4;
            if best_accuracy(train_session, test_session) > color_threshold
                %For contrast
                text_color = 'k';
            else
                text_color = 'w';
            end
            
            text(test_session, train_session, marker_text, ...
                'HorizontalAlignment', 'center', ...
                'Color', text_color, ...
                'FontSize', 20)
        end
     end   
end

nexttile();
imagesc(best_accuracy_normalized, [0 max(best_accuracy_normalized, [], 'all')]); 
cb = colorbar;
cb.Label.String = 'Normalized Percent correct (%)';
colormap(gca,inferno);
xticks(1:num_unique_sessions);
xticklabels(data_labels);
yticks(1:num_unique_sessions);
yticklabels(data_labels);
axis image;
colorplot_h = gca;
title('Normalized accuracy');
xlabel('Testing session');
ylabel('Training session');

if superimpose_significance
    marker_text = '*';
    
     for train_session = 1:num_sessions
        for test_session = 1:num_sessions
            significance_value = pvalues_accuracy(train_session, test_session);
            if significance_value<1e-6
                marker_text = '***';
            elseif significance_value<1e-4
                marker_text = '**';
            elseif significance_value<1e-2
                marker_text = '*';
            else
                marker_text = 'ns';
            end
            
            color_limits = colorplot_h.CLim;
            color_threshold = color_limits(1) + diff(color_limits)/2;
            if best_accuracy_normalized(train_session, test_session) > color_threshold
                %For contrast
                text_color = 'k';
            else
                text_color = 'w';
            end
            
            text(test_session, train_session, marker_text, ...
                'HorizontalAlignment', 'center', ...
                'Color', text_color, ...
                'FontSize', 20)
        end
     end   
end

nexttile();
imagesc(best_angular_error*180/pi, [min(best_angular_error*180/pi, [], 'all') 90]);
cb = colorbar;
cb.Label.String = 'MAAE (deg)';
colormap(gca, flipud(inferno));
xticks(1:num_unique_sessions);
xticklabels(data_labels);
yticks(1:num_unique_sessions);
yticklabels(data_labels);
axis image;
colorplot_h = gca;
title('MAAE');
xlabel('Testing session');
ylabel('Training session');

if superimpose_significance
    marker_text = '*';
     for train_session = 1:num_sessions
        for test_session = 1:num_sessions
            significance_value = pvalues_angular_error(train_session, test_session);
            if significance_value<1e-6
                marker_text = '***';
            elseif significance_value<1e-4
                marker_text = '**';
            elseif significance_value<1e-2
                marker_text = '*';
            else
                marker_text = 'ns';
            end
            
            color_limits = colorplot_h.CLim;
            color_threshold = color_limits(1) + diff(color_limits)/4;
            if 180/pi*best_angular_error(train_session, test_session) < color_threshold
                %For contrast
                text_color = 'k';
            else
                text_color = 'w';
            end
            
            text(test_session, train_session, marker_text, ...
                'HorizontalAlignment', 'center', ...
                'Color', text_color, ...
                'FontSize', 20)
        end
     end   
end

% Pvalue plot - accuracy
nexttile();
imagesc(log10(pvalues_accuracy));

cb = colorbar;
cb.Label.String = 'log10(pvalue)';
colormap(gca, flipud(inferno));
xticks(1:num_unique_sessions);
xticklabels(data_labels);
yticks(1:num_unique_sessions);
yticklabels(data_labels);
axis image;
colorplot_h = gca;
title('Accuracy pvalue');
xlabel('Testing session');
ylabel('Training session');

% Pvalue plot - MAAE
pvalues_plot = log10(pvalues_angular_error);
pvalues_plot(isinf(pvalues_plot)) = -5; % Limit of the boostrap
nexttile();
imagesc(pvalues_plot);
cb = colorbar;
cb.Label.String = 'log10(pvalue)';
colormap(gca, flipud(inferno));
xticks(1:num_unique_sessions);
xticklabels(data_labels);
yticks(1:num_unique_sessions);
yticklabels(data_labels);
axis image;
colorplot_h = gca;
title('Angular error pvalue');
xlabel('Testing session');
ylabel('Training session');

%% Compute similarity between each pair of images
similarity_metric = 'cwssim';

% If you don't use aligned angiogram, some of the metrics will not be as
% accurate. CWSSIM is designed to be the most robust against translation,
% rotations, and scaling.
use_aligned_angiogram = true;
if use_aligned_angiogram
    angiogram_to_use = angiogram_aligned;
else
    angiogram_to_use = repmat(angiogram_unaligned', num_unique_sessions, 1);
end

similarity_between_vascular_images = NaN(num_unique_sessions);
for image1 = 1:num_unique_sessions
    angiogram1 = double(angiogram_to_use{image1, image1});
    height1 = size(angiogram1, 1);
    
    figure;
    tiledlayout('flow');
    for image2 = 1:num_unique_sessions
        angiogram2 = double(angiogram_to_use{image1, image2});
        height2 = size(angiogram2, 1);
        % Pad to match image size
        if height1 > height2
            zero_matrix = zeros(height1-height2, size(angiogram1, 2));
            angiogram2_padded = [angiogram2; zero_matrix;];
            angiogram1_padded = angiogram1;
        elseif height1 < height2
            zero_matrix = zeros(height2-height1, size(angiogram1, 2));
            angiogram1_padded = [angiogram1; zero_matrix;];
            angiogram2_padded = angiogram2;
        else
            angiogram1_padded = angiogram1;
            angiogram2_padded = angiogram2;
        end
        
        % Scale to common range
        angiogram1_padded = scale_angiogram(angiogram1_padded);
        angiogram2_padded = scale_angiogram(angiogram2_padded);
        
        nexttile();
        imshowpair(angiogram1_padded, angiogram2_padded);
        
        switch similarity_metric
            case 'immse'
                similarity_between_vascular_images(image1, image2) = immse(angiogram1_padded, angiogram2_padded);
            case 'ssim'
                similarity_between_vascular_images(image1, image2) = ssim(angiogram1_padded, angiogram2_padded);
            case 'multissim'
                similarity_between_vascular_images(image1, image2) = multissim(angiogram1_padded, angiogram2_padded);
            case 'cwssim'
                similarity_between_vascular_images(image1, image2) = cwssim_index(angiogram1_padded, angiogram2_padded,4,16,0,0);
        end
    end
end

orange_colormap = getPyPlot_cMap('Oranges', 256, [], get_python_path);
blue_colormap = getPyPlot_cMap('Blues', 256, [], get_python_path);

figure; 
imagesc(similarity_between_vascular_images); colorbar;
colormap(blue_colormap);
xticks(1:num_unique_sessions);
xticklabels(data_labels);

yticks(1:num_unique_sessions);
yticklabels(data_labels);
title(sprintf('Angiogram similarity %s\n aligned - %s', similarity_metric, string(use_aligned_angiogram)));
axis image;

%% Plot performance vs SSIM
figure;
yyaxis left
splot_accuracy = plot(similarity_between_vascular_images(:), best_accuracy_normalized_1D, '.', ...
    'MarkerSize', 20);
ylabel('Normalized performance to benchmark');
ylim([0 max(best_accuracy_normalized_1D)]);
xlabel(similarity_metric);

title('Across-session performance as function of image similarity' );

% Calculate linear fit for accuracy vs image similarity
x = similarity_between_vascular_images(:);
y = best_accuracy_normalized_1D;
accuracy_mdl = fitlm(x, y);
accuracy_mdl_fit = polyfit(x, y, 1); % x = x data, y = y data, 1 = order of the polynomial i.e a straight line

[pear_corr_accuracy, corr_pvalue_accuracy] = corr(x, y);

hold on;
plot(x, polyval(accuracy_mdl_fit,x))
xlimits = xlim;
text(xlimits(1)+(0.05*(xlimits(2)-xlimits(1))), 0.05, ...
    sprintf('Accuracy R^2=%0.3f p=%0.3f', pear_corr_accuracy^2, corr_pvalue_accuracy));

hold off;

yyaxis right
splot_MAAE = plot(similarity_between_vascular_images(:), best_angular_error_1D, '.', ...
    'MarkerSize', 20);
ylabel('Angular error (deg)');
ylim([0 100]);


xlimits = xlim;
xlim([xlimits(1) 1.01]);

% Calculate linear fit for MAAE vs image similarity
x = similarity_between_vascular_images(:);
y = best_angular_error_1D;
MAAE_mdl = fitlm(x, y);
MAAE_mdl_fit = polyfit(x, y, 1);

[pear_corr_MAAE, corr_pvalue_MAAE] = corr(x, y);


hold on;
plot(x, polyval(MAAE_mdl_fit,x))
xlimits = xlim;
text(xlimits(1)+(0.05*(xlimits(2)-xlimits(1))), 10, ...
    sprintf('MAAE R^2=%0.3f p=%0.3f', pear_corr_MAAE^2, corr_pvalue_MAAE));

hold off;

legend([splot_accuracy splot_MAAE], 'Accuracy', 'MAAE', 'location', 'best');

%% Local functions
function scaled_angiogram = scale_angiogram(angiogram)
% Scale to [0 1]
min_intensity = min(angiogram, [], 'all');
max_intensity = max(angiogram, [], 'all');

scaled_angiogram = (angiogram - min_intensity)/ (max_intensity-min_intensity);
end
